using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using System.Text;
using System;
using System.Globalization;
using System.IO;
using UnityEditor;

namespace FontAwesome
{
    public static class FontAwesomeParser
    {
        [MenuItem("Foriero/Fonts/FontAwesome/Parse")]
        public static void ParseMenu()
        {
            string[] files = Directory.GetFiles(Directory.GetCurrentDirectory(), "variables.less", SearchOption.AllDirectories);

            if (files.Length > 0)
            {
                string output = Path.Combine(Path.GetDirectoryName(files[0]), "FontAwesome.Enums.cs");
                Parse(files[0], output);
            }
        }

        class IconObject
        {
            public string name;
            public string value;
            public string varName;

            public IconObject(string name, string value, string varName)
            {
                this.name = name;
                this.value = value;
                this.varName = varName;
            }
        }

        static void Parse(string inputFile, string outputFile)
        {
            Debug.Log("Input file path: " + inputFile);
            Debug.Log("Output file path: " + outputFile);

            List<IconObject> enums = new List<IconObject>();

            using (StreamReader reader = new StreamReader(inputFile, Encoding.Default))
            {
                do
                {
                    string line = reader.ReadLine();
                    if (line == null)
                        break;

                    const string varToken = "@fa-var-";
                    line = line.Trim();
                    if (!line.StartsWith(varToken))
                        continue;

                    int valuePos = line.IndexOf(':');
                    if (valuePos < 0)
                        continue;

                    string varName = line.Substring(varToken.Length, valuePos - varToken.Length);

                    string value = line.Substring(valuePos + 1).Trim();
                    if (!value.StartsWith("\"\\") || !value.EndsWith("\";"))
                        continue;

                    value = value.Substring(2, value.Length - 2 - 2);
                    string name = Camel(line.Substring(varToken.Length, valuePos - varToken.Length));
                    enums.Add(new IconObject(name, value, varName));
                } while (true);
            }

            if (enums.Count == 0)
            {
                Debug.Log("No variable was found.");
                return;
            }
            Debug.Log("Variables detected: " + enums.Count);

            using (StreamWriter writer = new StreamWriter(outputFile, false))
            {
                writer.WriteLine("//------------------------------------------------------------------------------");
                writer.WriteLine("// <auto-generated>");
                writer.WriteLine("//     This code was generated by a tool.");
                writer.WriteLine("//     Runtime Version:" + Environment.Version);
                writer.WriteLine("//");
                writer.WriteLine("//     Changes to this file may cause incorrect behavior and will be lost if");
                writer.WriteLine("//     the code is regenerated.");
                writer.WriteLine("// </auto-generated>");
                writer.WriteLine("//------------------------------------------------------------------------------");
                writer.WriteLine();

                writer.WriteLine("namespace FontAwesome");
                writer.WriteLine("{");
                writer.WriteLine("\t/// <summary>");
                writer.WriteLine("\t/// Font Awesome Resources.");
                writer.WriteLine("\t/// </summary>");
                writer.WriteLine("\tpublic enum FontAwesomeIconEnum");
                writer.WriteLine("\t{");
                for (int i = 0; i < enums.Count; i++)
                {
                    var kv = enums[i];
                    writer.WriteLine("\t\t/// <summary>");
                    writer.WriteLine("\t\t/// fa-" + kv.varName + " glyph (" + kv.value + ").");
                    writer.WriteLine("\t\t/// </summary>");
                    writer.Write('\t');
                    writer.Write('\t');
                    writer.Write(GetValidIdentifier(kv.name));
                    writer.Write(" = 0x");
                    writer.Write(kv.value);
                    if (i < (enums.Count - 1))
                    {
                        writer.WriteLine(',');
                    }
                    writer.WriteLine();
                }
                writer.WriteLine("\t}");
                writer.WriteLine("");

                writer.WriteLine("\t/// <summary>");
                writer.WriteLine("\t/// Font Awesome Resources.");
                writer.WriteLine("\t/// </summary>");
                writer.WriteLine("\tpublic static partial class FontAwesomeResource");
                writer.WriteLine("\t{");
                for (int i = 0; i < enums.Count; i++)
                {
                    var kv = enums[i];
                    writer.WriteLine("\t\t/// <summary>");
                    writer.WriteLine("\t\t/// fa-" + kv.varName + " glyph (" + kv.value + ").");
                    writer.WriteLine("\t\t/// </summary>");
                    writer.WriteLine("\t\tpublic const char " + GetValidIdentifier(kv.name) + " = '\\u" + kv.value + "';");
                    if (i < (enums.Count - 1))
                    {
                        writer.WriteLine();
                    }
                }
                writer.WriteLine("\t}");
                writer.WriteLine("}");
            }
            Debug.Log("Output file was successfully written.");
        }

        static string Camel(string s)
        {
            if (s == null)
                return s;

            StringBuilder sb = new StringBuilder(s.Length);
            bool next = false;
            for (int i = 0; i < s.Length; i++)
            {
                if (i == 0)
                {
                    sb.Append(char.ToUpper(s[i]));
                    continue;
                }

                if (s[i] == '-')
                {
                    next = true;
                    continue;
                }

                if (next)
                {
                    sb.Append(char.ToUpper(s[i]));
                    next = false;
                }
                else
                {
                    sb.Append(s[i]);
                }
            }
            return sb.ToString();
        }

        static string GetValidIdentifier(string text)
        {
            if (string.IsNullOrEmpty(text))
                throw new ArgumentNullException("text");

            int start = 0;
            StringBuilder sb = new StringBuilder(text.Length);
            if (IsValidIdentifierStart(text[0]))
            {
                sb.Append(text[0]);
                start = 1;
            }
            else
            {
                sb.Append('_');
            }

            bool nextUpper = false;
            for (int i = start; i < text.Length; i++)
            {
                if (IsValidIdentifierPart(text[i]))
                {
                    if (nextUpper)
                    {
                        sb.Append(char.ToUpper(text[i], CultureInfo.CurrentCulture));
                        nextUpper = false;
                    }
                    else
                    {
                        sb.Append(text[i]);
                    }
                }
                else
                {
                    if (text[i] == ' ')
                    {
                        nextUpper = true;
                    }
                    else
                    {
                        sb.Append('_');
                    }
                }
            }
            return sb.ToString();
        }

        static bool IsValidIdentifierStart(char character)
        {
            if (character == '_')
                return true;

            UnicodeCategory category = CharUnicodeInfo.GetUnicodeCategory(character);
            switch (category)
            {
                case UnicodeCategory.UppercaseLetter://Lu
                case UnicodeCategory.LowercaseLetter://Ll
                case UnicodeCategory.TitlecaseLetter://Lt
                case UnicodeCategory.ModifierLetter://Lm
                case UnicodeCategory.OtherLetter://Lo
                case UnicodeCategory.LetterNumber://Nl
                    return true;

                default:
                    return false;
            }
        }

        static bool IsValidIdentifierPart(char character)
        {
            UnicodeCategory category = CharUnicodeInfo.GetUnicodeCategory(character);
            switch (category)
            {
                case UnicodeCategory.UppercaseLetter:
                case UnicodeCategory.LowercaseLetter:
                case UnicodeCategory.TitlecaseLetter:
                case UnicodeCategory.ModifierLetter:
                case UnicodeCategory.LetterNumber:
                case UnicodeCategory.NonSpacingMark:
                case UnicodeCategory.SpacingCombiningMark:
                case UnicodeCategory.DecimalDigitNumber:
                case UnicodeCategory.ConnectorPunctuation:
                case UnicodeCategory.Format:
                    return true;

                default:
                    return false;
            }
        }
    }
}